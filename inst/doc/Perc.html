<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><strong>Abstract</strong>  </p>

<p>Dominance structure of animal societies is likely to be more complex than simple linearity, but few, if any, methods exist for quantifying nonlinear structure. Our R package “Perc” presented a new network-based method, called Percolation and Conductance, which permits nonlinear structure in dominance interactions. It uses information from both direct and indirect dominance pathways to calculate consistency in the direction of transitive dominance pathways from A to B (e.g. via pathway through C, D, and/or E). Greater consistency results in higher certainty that A outranks B. It creates a matrix of probabilities that the row individual outranks the column individual. It performs simulated annealing processes to explore possible rank orders and finds the best possible rank order. By applying simple R functions, researchers will be able to quantify rank order and dominance uncertainty with the help of the package. </p>

<h2>Introduction</h2>

<p>Rank relationships amongst members of a social group are most commonly represented as an ordered list of individuals that are ranked from highest to lowest. Numerous methods exist to identify this rank order, and most methods fall under one of two approaches: (1) finding the appropriate ranking by reordering the rows and columns of a win/loss matrix or (2) calculating a cardinal dominance index which ranks individuals by the proportion of others dominated, both of which are based upon a data set of agonistic and/or submissive interactions. Such methods produce a linear rank order, whether or not the society is expected to have a linear hierarchy or whether the data fit the assumption of linearity (which is particularly problematic when calculating cardinal ranks (Shev et al 2012)). Most researchers agree that the dominance structure of animal societies is likely to be more complex than simple linearity, but few, if any, methods exist for quantifying nonlinear structure. We present a new network-based method, called Percolation and Conductance, that permits nonlinear structure to emerge via estimates of network-wide directional consistency in the flow of dominance interactions and detection of blocks of dominance ambiguity that are indicative of nonlinear segments of a hierarchy. An additional benefit of this method is the ability to quantify dyadic-level dominance certainty. Dyadic dominance potentials are calculated using multiple indirect dominance pathways in the network (via common third parties) to infer missing data in the win/loss matrix and enhance the calculation of dominance potentials from direct interactions. Greater consistency in the direction of transitive dominance pathways from A to B (e.g. via pathway through C, D, and/or E) result in higher certainty that A outranks B, whereas greater evidence of inconsistent direction (e.g. some directed pathways go from A to B whereas other directed pathways go from B to A) result in dominance ambiguity. Because the number of indirect pathways is typically exponentially larger than direct win/loss interactions, one can be relatively confident that dyads with ambiguous dominance potentials are truly ambiguous due to evidence of directional inconsistency in their network pathways rather than lack of data. </p>

<h2>Rationale</h2>

<p>Rank order using the percolation-conductance method is based on a matrix that combines information from direct win/loss interactions with information from indirect pathways as described above to create a matrix of probabilities that the row individual outranks the column individual. Percolation-conductance finds these multi-step, directed pathways between all pairs of nodes by performing a series of random walks through the network. A simulated annealing process explores possible rank orders (from the space of all possible rank orders) – the more simulated annealing runs that are performed, a larger number of possible rank orders are explored, meaning that the best possible rank order is more likely to be found.  The starting location of simulated annealing is determined by the total wins per individual in the matrix. Multiple simulated annealing steps are required to arrive at the optimal rank order, keeping in mind that multiple rank orders may be equally good if there are nonlinear segments in the hierarchy. The heat map function (plot.conf.mat) will plot the ranking and can allow for the detection of non-linear dominance structures. A block of individuals with probabilities near 0.5 indicates a subgroup of individuals whose relationships are not clearly defined. A second metric yielded by this method, dominance uncertainty, reflects the directional consistency of information flow through the direct and indirect pathways in a directed and weighted network.</p>

<p>The Percolation-Conductance method of quantifying rank and dominance uncertainty is computation complicated and requires researchers to have a sophisticated computational background to process the data. Our group, in collaboration with collaboraters in UC Davis Statistics Deparment, developed an R package that implements the percolation-conductance algorithm on directed dyadic interactions. By applying simple R functions, researchers will be able to quantify rank order and dominance uncertainty with the help of the package. The goal of this tutorial is to show how to quantify rank and dominance uncertainty from win-loss raw data.</p>

<h2>User Manual</h2>

<h4>Importing Data</h4>

<p>The function <code>as.conflictmat</code> is used to import raw edgelists or matrices for further analysis. Raw edgelists or matrices are records for directed dyadic win-loss interactions. The prefered R data types for <code>as.conflictmat</code> are &ldquo;<code>matrix</code>&rdquo; and &ldquo;<code>data.frame</code>&rdquo;. Raw edgelists or matrices can be imported as R data type of either <code>data.frame</code> or <code>matrix</code> to be used in <code>as.conflictmat</code>. </p>

<h5>Preparing raw data</h5>

<p>The most simple and commonly used raw data is a <strong>edgelist of two columns</strong> consisting all dyadic win-loss interactions, with the first columns being the winner and the second column being the loser. Duplicates are allowed in this two-column edgelist because multiple interactions between a pair are represented by multiple rows of the same winner and loser. Below is an example of a two-column edgelist.</p>

<pre><code class="r">library(Perc)

# displaying the first 5 rows of the example data.
head(sampleEdgelist, 5)
</code></pre>

<pre><code>##   Iname  Rname
## 1  Kale Kibitz
## 2  Kale Kibitz
## 3  Kale Kibitz
## 4  Kale Kibitz
## 5  Kale Kolyma
</code></pre>

<p><strong>A weighted edgelist</strong> is also allowed as raw edgelist data. It is a &ldquo;<code>matrix</code>&rdquo; or &ldquo;<code>data.frame</code>&rdquo; of three columns, with the first two columns being winner IDs and loser IDs respectively and the third column being the frequency of the win-loss interaction between the winner and the loser. An example of a weighted edgelsit is shown below:</p>

<pre><code class="r"># displaying the first 5 rows of the example data.
head(sampleWeightedEdgelist, 5)
</code></pre>

<pre><code>##   Initiator1   Recipient1 Freq
## 1   Angelina       Alexis    1
## 2   Angelina        Darcy    1
## 3   Angelina FirstTimeMom    1
## 4   Angelina          Mak    1
## 5   Angelina      Tabitha    3
</code></pre>

<p>In addition, <strong>a matrix representing dyadic win-loss interaction</strong> is also accepted as raw data. For example,</p>

<pre><code class="r"># displaying the first 5 rows and columns
sampleRawMatrix[1:5, 1:5]
</code></pre>

<pre><code>##             Alexis Angelina Aristotle BaldSpotMom C19
## Alexis           0        0         0           0   0
## Angelina         1        0         0           0   0
## Aristotle        0        0         0           0   0
## BaldSpotMom      6        0         0           0   0
## C19              0        0         0           0   0
</code></pre>

<h5>Importing your raw data</h5>

<p>The function <code>as.conflictmat</code> is used to import raw data of any accepted format, transform raw data to a &ldquo;<code>conflict matrix</code>&rdquo; for further analysis. &ldquo;<code>conflict matrix</code>&rdquo; is very specifically refered to a class in R. If your raw data is an edgelist of either two- or three- column, it will transform the your raw edgelist to a matrix in which counts representing for how many times a row wins over a column. Running this on a win-loss matrix creates an identical conflict matrix. This is required for all data formats to create R object of class conflict matrix.</p>

<p>Below is an example on transforming a two-column edgelist:</p>

<pre><code class="r"># convert an two-column edgelist to conflict matrix
confmatrix &lt;- as.conflictmat(sampleEdgelist)

# displaying the first 5 rows and columns of the converted matrix
confmatrix[1:5, 1:5]
</code></pre>

<pre><code>##          Kalani Kale Kalleigh Keira Kibitz
## Kalani        0    0        0     0      0
## Kale          0    0        0     0      4
## Kalleigh      0    1        0     0      0
## Keira         0    0        0     0      0
## Kibitz        0    6        0     0      0
</code></pre>

<p>Below is an example on transforming a raw win-loss matrix:</p>

<pre><code class="r"># convert a win-loss matrix to conflict matrix
confmatrix2 &lt;- as.conflictmat(sampleRawMatrix)

# displaying the first 5 rows and columns of the converted matrix
confmatrix2[1]
</code></pre>

<pre><code>## [1] 0
</code></pre>

<p>When importing weighted edgelist (three-column), you&#39;ll need to specify <code>weighted = TRUE</code> if your raw data is a weighted edgelist. Below is an example:</p>

<pre><code class="r">confmatrix3 &lt;- as.conflictmat(sampleWeightedEdgelist, weighted = TRUE)
</code></pre>

<p><strong>Directionality</strong> is very importnat when using the function <code>as.conflictmat</code> to import raw data. By default, winners (sources) are in the first column and loses (targets) are in the second column for edgelists. Row names are assumed to be the winner for a raw win-loss matrix. Values in a raw win-loss matrix describe that for how many times the corresponding row ID win over the corresponding column ID. If the directionality in your raw data happens to be opposite from the default, you could specify <code>swap.order = TRUE</code> in <code>as.conflictmat</code>. It will tell R that the directionality in your raw data is the opposite of default setting. Running <code>as.conflictmat</code> on your raw data with <code>swap.order = TRUE</code> will automatically correct the directionality when transforming your raw data to a <code>conflict matrix</code>. Here is an example,</p>

<pre><code class="r"># displaying the first 5 rows and columns of the raw win-loss matrix
sampleRawMatrix[1:5, 1:5]
</code></pre>

<pre><code>##             Alexis Angelina Aristotle BaldSpotMom C19
## Alexis           0        0         0           0   0
## Angelina         1        0         0           0   0
## Aristotle        0        0         0           0   0
## BaldSpotMom      6        0         0           0   0
## C19              0        0         0           0   0
</code></pre>

<pre><code class="r"># use swap.order = TRUE when running as.conflictmat.
confmatrix4 &lt;- as.conflictmat(sampleRawMatrix, swap.order = TRUE)

# displaying the first 5 rows and columns of the converted matrix
confmatrix4[1:5, 1:5]
</code></pre>

<pre><code>##             Alexis Angelina Aristotle BaldSpotMom C19
## Alexis           0        1         0           6   0
## Angelina         0        0         0           0   0
## Aristotle        0        0         0           0   0
## BaldSpotMom      0        0         0           0   0
## C19              0        0         0           0   0
</code></pre>

<h4>Examining the network</h4>

<p>Before computing the dominance probability and finding the best rank order, you want to know whether or not long pathways are present in your data, and if present, whether or not these long pathways can be useful for gathering additional information about rank relationships.</p>

<p>You could find pathways of <strong>particular length</strong> that <strong>starting</strong> at a particular node (ID). For example,</p>

<pre><code class="r"># Testing findIDpaths.R
pathKuai &lt;- findIDpaths(confmatrix, &quot;Kuai&quot;, len = 3)
# Displaying the first 5 rows of pathKuai
pathKuai[1:5, ]
</code></pre>

<pre><code>##      [,1]   [,2]       [,3]     [,4]    
## [1,] &quot;Kuai&quot; &quot;Kalleigh&quot; &quot;Kale&quot;   &quot;Kibitz&quot;
## [2,] &quot;Kuai&quot; &quot;Kalleigh&quot; &quot;Kale&quot;   &quot;Kolyma&quot;
## [3,] &quot;Kuai&quot; &quot;Kalleigh&quot; &quot;Kimora&quot; &quot;Kibitz&quot;
## [4,] &quot;Kuai&quot; &quot;Kalleigh&quot; &quot;Kimora&quot; &quot;Kioga&quot; 
## [5,] &quot;Kuai&quot; &quot;Kalleigh&quot; &quot;Kimora&quot; &quot;Koppy&quot;
</code></pre>

<pre><code class="r"># When there&#39;s no pathway starting at a particular individual, you&#39;ll get an output like the example below: 
pathKalani &lt;- findIDpaths(confmatrix, ID = &quot;Kalani&quot;, len = 2)
</code></pre>

<pre><code>## no pathways of length 2 found starting at Kalani
</code></pre>

<p>You could also use <code>transitivity</code> to find out information on transitivity, a measure of how consistent or inconsistent the flow of information is through the network as a whole.  This procedure looks for the number of triangles (e.g. A<U+2192>B<U+2192>C<U+2192>A) and determines whether or not they are transitive. </p>

<pre><code class="r">conftrans &lt;- transitivity(confmatrix)
conftrans$transitive      # number of transitive triangles
</code></pre>

<pre><code>## [1] 14
</code></pre>

<pre><code class="r">conftrans$intransitive    # number of intransitive triangles
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">conftrans$transitivity    # transitivity
</code></pre>

<pre><code>## [1] 0.7777778
</code></pre>

<pre><code class="r">conftrans$alpha           # alpha
</code></pre>

<pre><code>## [1] 6.468627
</code></pre>

<p>The function <code>transitivity</code> allow estimation for <code>alpha</code>, which is a value used in the conductance procedure to weight the information from the indirect pathways.  The higher the transitivity of a network (the higher the alpha), the greater the weight the conductance procedure will give the indirect pathways.</p>

<h4>Finding Rank Order</h4>

<p>After transforming your raw data in an R object of <code>conflict matrix</code> class, we will use the function <code>conductance</code> to find all indirect pathways of a particular length (defined by <code>maxLength</code>) and update the conflict matrix. The maximum length of indirect pathways should be decided based on the data.  We use a max length of 4 for our dominance rank. This yields the dominance probability matrix which represents the probability the row outranks the column. Values in the matrix are from 0 - 1, with 0.5 being the most uncertain. If a value is less than 0.5, the corresponding row ID is more likely to lose against the corresponding column ID; if a value is greater than 0.5, the corresponding row ID is more likely to win over the corresponding column ID.</p>

<pre><code class="r">DominanceProbability &lt;- conductance(confmatrix, maxLength = 2)
</code></pre>

<p><code>DominanceProbability</code> is a list of 2 elements. The first element, named <code>imputed.conf</code> is the updated conflict matrix which incorporates information from indirect pathways from the original conflict matrix. Comparing the original conflict matrix with the updated conflict matrix will show the information that is gained through the indirect pathways: </p>

<pre><code class="r"># displaying the first 5 rows and columns of the original conflict matrix
confmatrix[1:5, 1:5]
</code></pre>

<pre><code>##          Kalani Kale Kalleigh Keira Kibitz
## Kalani        0    0        0     0      0
## Kale          0    0        0     0      4
## Kalleigh      0    1        0     0      0
## Keira         0    0        0     0      0
## Kibitz        0    6        0     0      0
</code></pre>

<pre><code class="r"># displaying the first 5 rows and columns of the imputed conflict matrix
DominanceProbability$imputed.conf[1:5, 1:5]
</code></pre>

<pre><code>##              Kalani     Kale Kalleigh      Keira    Kibitz
## Kalani   0.00000000 0.000000        0 0.00000000 0.0000000
## Kale     0.00000000 0.000000        0 0.00000000 4.0557534
## Kalleigh 0.05575338 1.000000        0 0.11150676 0.2230135
## Keira    0.00000000 0.000000        0 0.00000000 0.0000000
## Kibitz   0.00000000 6.055753        0 0.05575338 0.0000000
</code></pre>

<p>Examining information gained through indirect pathways will provide you information to decide what is the appropriate <code>maxLength</code> for your data. You could examine the information gained through indirect pathways by substracting the original conflict matrix from imputed conflict matrix. The information gained could visually examined by generating a corresponding heatmap using the function <code>plot.conf.mat</code>.</p>

<pre><code class="r"># substracting the original conflict matrix from imputed conflict matrix.
informationGain &lt;- DominanceProbability$imputed.conf - confmatrix

# examine the first five rows and columns of the informationGain
informationGain[1:5, 1:5]
</code></pre>

<pre><code>##              Kalani       Kale Kalleigh      Keira     Kibitz
## Kalani   0.00000000 0.00000000        0 0.00000000 0.00000000
## Kale     0.00000000 0.00000000        0 0.00000000 0.05575338
## Kalleigh 0.05575338 0.00000000        0 0.11150676 0.22301352
## Keira    0.00000000 0.00000000        0 0.00000000 0.00000000
## Kibitz   0.00000000 0.05575338        0 0.05575338 0.00000000
</code></pre>

<pre><code class="r"># generating a heatmap representing information gained by using informatio from indirect pathways.
plotConfmat(informationGain, ordering = NA, labels = TRUE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-12"/></p>

<p>As we could see from the heatmap, using <code>maxLength = 2</code> does provide us more information than the original raw conflict matrix that we imported from the raw data. In real analysis, you may want to consider using <code>maxLength = 3</code> or even more and repeat this diagnosis process to examine the information gain. This will allow you to have a better idea on what is the appropriate <code>maxLength</code> for your data.</p>

<p>For example, if you want to examine whether or not <code>maxLength = 3</code> provide more information than <code>maxLength = 2</code>. Here is an example:</p>

<pre><code class="r">DominanceProbabilityLength3 &lt;- conductance(confmatrix, maxLength = 3)
informationGain2 &lt;- DominanceProbabilityLength3$imputed.conf - DominanceProbability$imputed.conf
plotConfmat(informationGain2, ordering = NA, labels = TRUE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13"/>
As we can see in this heatmap that using <code>maxLength = 3</code> still gives you some more information. In real analysis, you may want to repeat the analysis and try <code>maxLength = 4</code>. In addition, you may also want to consider your alpha value to decide how much you want to trust those long pathways.</p>

<p>The second element of <code>DominanceProbability</code> the dominance probability matrix, named <code>p.hat</code>. Here&#39;s how you could pull out the dominance probability matrix:</p>

<pre><code class="r"># displaying the first 5 rows and columns of the dominance probability matrix
DominanceProbability$p.hat[1:5, 1:5]
</code></pre>

<pre><code>##             Kalani      Kale  Kalleigh     Keira    Kibitz
## Kalani   0.0000000 0.5000000 0.4236125 0.5000000 0.5000000
## Kale     0.5000000 0.0000000 0.1180829 0.5000000 0.4040371
## Kalleigh 0.5763875 0.8819171 0.0000000 0.6325280 0.7095211
## Keira    0.5000000 0.5000000 0.3674720 0.0000000 0.4236125
## Kibitz   0.5000000 0.5959629 0.2904789 0.5763875 0.0000000
</code></pre>

<p>When you want to use dominance probability matrix for further analysis, often a long-format representation of the matrix is easier. The function <code>dyadicLongConverter</code> convert win-loss uncertainty to long format.  </p>

<pre><code class="r"># displaying the first 5 rows of the converted long format win-loss probability.
dyadicLongConverter(DominanceProbability$p.hat)[1:5, ]
</code></pre>

<pre><code>##       ID1      ID2 ID1 Win Probability ID2 Win Probability
## 12 Kalani     Kale           0.5000000           0.5000000
## 23 Kalani Kalleigh           0.4236125           0.5763875
## 24   Kale Kalleigh           0.1180829           0.8819171
## 34 Kalani    Keira           0.5000000           0.5000000
## 35   Kale    Keira           0.5000000           0.5000000
##    RankingCertainty
## 12        0.5000000
## 23        0.5763875
## 24        0.8819171
## 34        0.5000000
## 35        0.5000000
</code></pre>

<p>Simulated rank order is computed using a simulated annealing algorithm by running the function <code>simRankOrder</code> on <code>DominanceProbability$p.hat</code>. The argument <code>num</code> is the number of simulated annealing runs to generate best rank order. The argument <code>kmax</code> tells you how long (perhaps iterations) the simulated annealing function looks around for a local optimum to find the best rank order. By default, <code>kmax = 1000</code> was used. But it takes a long time to run when using <code>kmax = 1000</code>. The example below uses kmax = 10 just because it runs quickly and it is enough to illustrate the process, however this value is not recommended when processing real data. Here is how to use <code>simRankOrder</code> to find the simulated rank order:</p>

<pre><code class="r"># find simRankOrder
s.rank &lt;- simRankOrder(DominanceProbability$p.hat, num = 10, kmax = 10)
</code></pre>

<p>The function <code>s.rank</code> returns a list containing simulated rank order and Costs for each simulated annealing run. The best rank order will be the one with the lowest cost.</p>

<pre><code class="r"># displaying the first 5 rows of the simulated rank order
s.rank$BestSimulatedRankOrder[1:5, ]
</code></pre>

<pre><code>##         ID ranking
## 1    Koppy       1
## 2    Kioga       2
## 3     Kuai       3
## 4 Kalleigh       4
## 5   Kyushu       5
</code></pre>

<pre><code class="r"># displaying cost for each simulated annealing run
s.rank$Costs
</code></pre>

<pre><code>##    simAnnealRun     Cost
## 1             1 2.321503
## 2             2 2.392065
## 3             3 2.392065
## 4             4 2.392065
## 5             5 2.321503
## 6             6 2.392065
## 7             7 2.392065
## 8             8 2.321503
## 9             9 2.321503
## 10           10 2.392065
</code></pre>

<pre><code class="r"># rank orders generated by each simulated annealing run 
s.rank$AllSimulatedRankOrder
</code></pre>

<pre><code>##    SimAnneal1 SimAnneal2 SimAnneal3 SimAnneal4 SimAnneal5 SimAnneal6
## 1       Koppy      Koppy      Koppy      Koppy      Koppy      Koppy
## 2       Kioga      Kioga      Kioga      Kioga      Kioga      Kioga
## 3        Kuai   Kalleigh   Kalleigh   Kalleigh       Kuai   Kalleigh
## 4    Kalleigh     Kyushu     Kyushu     Kyushu   Kalleigh     Kyushu
## 5      Kyushu     Kimora     Kimora     Kimora     Kyushu     Kimora
## 6      Kimora       Kuai       Kuai       Kuai     Kimora       Kuai
## 7      Kibitz     Kibitz     Kibitz     Kibitz     Kalani     Kibitz
## 8       Keira     Kolyma     Kolyma      Keira     Kibitz      Keira
## 9      Kalani       Kale     Kalani     Kalani     Kolyma     Kalani
## 10     Kolyma      Keira       Kale     Kolyma       Kale     Kolyma
## 11       Kale     Kalani      Keira       Kale      Keira       Kale
##    SimAnneal7 SimAnneal8 SimAnneal9 SimAnneal10
## 1       Koppy      Koppy      Koppy       Koppy
## 2       Kioga      Kioga      Kioga       Kioga
## 3    Kalleigh       Kuai       Kuai    Kalleigh
## 4      Kyushu   Kalleigh   Kalleigh      Kyushu
## 5      Kimora     Kyushu     Kyushu      Kimora
## 6        Kuai     Kimora     Kimora        Kuai
## 7      Kalani     Kibitz     Kibitz      Kalani
## 8      Kibitz     Kalani     Kolyma      Kibitz
## 9       Keira     Kolyma     Kalani      Kolyma
## 10     Kolyma       Kale      Keira       Keira
## 11       Kale      Keira       Kale        Kale
</code></pre>

<p>After finding the simulated rank order, you can apply the rank order to your dominance probability matrix in order to generate a heatmap with its rows and columns ordered by rank.  This heatmap will highlight areas of non-linear dominance rank (i.e. areas that are brown in the example below).  A block of individuals with probabilities near 0.5 indicates a subgroup of individuals whose relationships are not clearly defined.</p>

<pre><code class="r">plotConfmat(DominanceProbability$p.hat, ordering = s.rank[[1]]$ID, labels = TRUE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-18"/></p>

<h5>Regarding Dominance Certainty</h5>

<p>Besides ranking information, the undirected certainty information in dominance relationship is also important. The values in the dominance probability matrix range from 0-1 indicating both the direction of the relationship and the certainty of the relationship. The function <code>valueConverter</code> converts all values to values between 0.5 - 1.0, which, in essence, removes directionality from the relationship leaving a single metric of dominance certainty (0.5 indicates total uncertainty and 1.0 indicates total certainty). For example,</p>

<pre><code class="r"># displaying the first 5 rows and columns of the converted matrix
valueConverter(DominanceProbability$p.hat)[1:5, 1:5]
</code></pre>

<pre><code>##             Kalani      Kale  Kalleigh     Keira    Kibitz
## Kalani   1.0000000 0.5000000 0.5763875 0.5000000 0.5000000
## Kale     0.5000000 1.0000000 0.8819171 0.5000000 0.5959629
## Kalleigh 0.5763875 0.8819171 1.0000000 0.6325280 0.7095211
## Keira    0.5000000 0.5000000 0.6325280 1.0000000 0.5763875
## Kibitz   0.5000000 0.5959629 0.7095211 0.5763875 1.0000000
</code></pre>

<p>When you want to understand dyadic level dominance uncertainty, you could get the information from <code>dyadicLongConverter</code>. For example,</p>

<pre><code class="r"># displaying the first 5 rows of Ranking Certainty
dyadicLongConverter(DominanceProbability$p.hat)[1:5, c(&quot;ID1&quot;, &quot;ID2&quot;, &quot;RankingCertainty&quot;)]
</code></pre>

<pre><code>##       ID1      ID2 RankingCertainty
## 12 Kalani     Kale        0.5000000
## 23 Kalani Kalleigh        0.5763875
## 24   Kale Kalleigh        0.8819171
## 34 Kalani    Keira        0.5000000
## 35   Kale    Keira        0.5000000
</code></pre>

<p>When individual-level win-loss relationship uncertainty is the focus of your question, the function <code>individualDomProb</code> computes the mean and standard deviation for individual-level win-loss probability. </p>

<pre><code class="r">individualDomProb(DominanceProbability$p.hat)[1:10,]
</code></pre>

<pre><code>##          ID      Mean        SD
## 1    Kalani 0.6079515 0.1705907
## 2      Kale 0.6403923 0.1628646
## 3  Kalleigh 0.7350389 0.1343705
## 4     Keira 0.6606999 0.1782413
## 5    Kibitz 0.6974806 0.1677272
## 6    Kimora 0.7269768 0.1736934
## 7     Kioga 0.7037738 0.1644045
## 8    Kolyma 0.6072364 0.1559790
## 9     Koppy 0.7157361 0.1433639
## 10     Kuai 0.6873502 0.1703318
</code></pre>

</body>

</html>
